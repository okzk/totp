package totp

import (
	"reflect"
	"testing"
	"time"
)

type TestData struct {
	t    time.Time
	code string
}

func TestGenerateCodeWithSha1(t *testing.T) {
	secret := []byte("12345678901234567890")
	key, err := NewKey(Secret(secret))
	if err != nil {
		t.Fatal(err)
	}

	data := []TestData{
		{time.Unix(1000000000, 0), "864010"},
		{time.Unix(1111111111, 0), "050471"},
		{time.Unix(1234567789, 0), "622147"},
		{time.Unix(2000000000, 0), "279037"},
		{time.Unix(2222222222, 0), "300947"},
	}

	for _, d := range data {
		actual := key.GenerateCodeAt(d.t)
		if actual != d.code {
			t.Errorf("code for %v is wrong. expected: %s actual: %s", d.t, d.code, actual)
		}
	}
}

func TestGenerateCodeWithSha256(t *testing.T) {
	secret := []byte("12345678901234567890")
	key, err := NewKey(Secret(secret), Algorithm("sha256"))
	if err != nil {
		t.Fatal(err)
	}

	data := []TestData{
		{time.Unix(1000000000, 0), "876097"},
		{time.Unix(1111111111, 0), "584430"},
		{time.Unix(1234567789, 0), "336929"},
		{time.Unix(2000000000, 0), "428693"},
		{time.Unix(2222222222, 0), "242329"},
	}

	for _, d := range data {
		actual := key.GenerateCodeAt(d.t)
		if actual != d.code {
			t.Errorf("code for %v is wrong. expected: %s actual: %s", d.t, d.code, actual)
		}
	}
}

func TestGenerateCodeWithSha512(t *testing.T) {
	secret := []byte("12345678901234567890")
	key, err := NewKey(Secret(secret), Algorithm("sha512"))
	if err != nil {
		t.Fatal(err)
	}

	data := []TestData{
		{time.Unix(1000000000, 0), "029236"},
		{time.Unix(1111111111, 0), "380122"},
		{time.Unix(1234567789, 0), "693607"},
		{time.Unix(2000000000, 0), "464532"},
		{time.Unix(2222222222, 0), "763222"},
	}

	for _, d := range data {
		actual := key.GenerateCodeAt(d.t)
		if actual != d.code {
			t.Errorf("code for %v is wrong. expected: %s actual: %s", d.t, d.code, actual)
		}
	}
}

func TestGenerateCodeWithOtherOptions(t *testing.T) {
	secret := []byte("12345678901234567890")
	key, err := NewKey(Secret(secret), Period(60), Digits(8))
	if err != nil {
		t.Fatal(err)
	}

	data := []TestData{
		{time.Unix(1000000000, 0), "68889571"},
		{time.Unix(1111111111, 0), "19360094"},
		{time.Unix(1234567789, 0), "63143920"},
		{time.Unix(2000000000, 0), "76864010"},
		{time.Unix(2222222222, 0), "14050471"},
	}

	for _, d := range data {
		actual := key.GenerateCodeAt(d.t)
		if actual != d.code {
			t.Errorf("code for %v is wrong. expected: %s actual: %s", d.t, d.code, actual)
		}
	}
}

func TestAutoGeneratedSecret(t *testing.T) {
	data := map[string]int{
		"sha1":   160,
		"sha256": 256,
		"sha512": 512,
	}

	for alg, bits := range data {
		key, err := NewKey(Algorithm(alg))
		if err != nil {
			t.Fatal(err)
		}
		if len(key.secret)*8 > bits {
			t.Errorf("auto generated secret for %s does not have enough length", alg)
		}
	}
}

func TestTruncatedStringCode(t *testing.T) {
	data := map[int]string{
		0:        "000000",
		10:       "000010",
		110:      "000110",
		1101:     "001101",
		11101:    "011101",
		211101:   "211101",
		1234567:  "234567",
		12345678: "345678",
		90005678: "005678",
	}

	for input, expected := range data {
		actual := truncatedStringCode(input, 6)
		if actual != expected {
			t.Errorf("truncatedStringCode failed. input: %d expected: %s actual: %s", input, expected, actual)
		}
	}
}

type noopEncDecrypter struct{}

func (noop *noopEncDecrypter) Encrypt(msg []byte) ([]byte, error) {
	return msg, nil
}
func (noop *noopEncDecrypter) Decrypt(msg []byte) ([]byte, error) {
	return msg, nil
}

func TestEncDecrypt(t *testing.T) {
	src, err := NewKey()
	if err != nil {
		t.Fatal(err)
	}
	noop := &noopEncDecrypter{}
	encypted, err := src.ToEncryptedString(noop)
	if err != nil {
		t.Fatal(err)
	}
	dst, err := FromEncryptedString(encypted, noop)
	if err != nil {
		t.Fatal(err)
	}

	if src.algorithm != dst.algorithm || src.digits != dst.digits || src.period != dst.period || !reflect.DeepEqual(src.secret, dst.secret) {
		t.Error("encrypt - decrypt error")
	}
}
